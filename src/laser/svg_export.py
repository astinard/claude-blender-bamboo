"""
SVG Export for Laser Cutting Paths.

Generates SVG files from 2D paths for laser cutting.
Supports different stroke colors for cut/engrave operations.
"""

from dataclasses import dataclass
from typing import List, Tuple, Optional, Dict
from pathlib import Path
import xml.etree.ElementTree as ET
from xml.dom import minidom

from .cross_section import Path2D, CrossSectionResult
from .projection import ProjectionResult


@dataclass
class SVGStyle:
    """SVG stroke style for laser operations."""
    stroke_color: str = "#000000"
    stroke_width: float = 0.1
    fill: str = "none"
    operation: str = "cut"  # 'cut', 'engrave', 'score'


# Default styles for different operations
SVG_STYLES = {
    'cut': SVGStyle(stroke_color="#FF0000", stroke_width=0.1, operation='cut'),
    'engrave': SVGStyle(stroke_color="#0000FF", stroke_width=0.5, operation='engrave'),
    'score': SVGStyle(stroke_color="#00FF00", stroke_width=0.1, operation='score'),
    'outline': SVGStyle(stroke_color="#000000", stroke_width=0.1, operation='cut'),
}


class SVGExporter:
    """
    Exports 2D paths to SVG format for laser cutting.

    Features:
    - Multiple path styles (cut, engrave, score)
    - Automatic sizing and centering
    - Support for multiple paths
    - Metadata embedding

    Usage:
        exporter = SVGExporter()
        svg_content = exporter.export(paths, style='cut')
        exporter.save(paths, 'output.svg')
    """

    def __init__(self, unit: str = "mm", precision: int = 3):
        """
        Initialize SVG exporter.

        Args:
            unit: Output unit (mm, in, px)
            precision: Decimal precision for coordinates
        """
        self.unit = unit
        self.precision = precision

    def paths_to_svg(self, paths: List[Path2D],
                     style: str = 'cut',
                     width: Optional[float] = None,
                     height: Optional[float] = None,
                     margin: float = 5.0) -> str:
        """
        Convert paths to SVG string.

        Args:
            paths: List of Path2D objects
            style: Style name ('cut', 'engrave', 'score')
            width: Override SVG width
            height: Override SVG height
            margin: Margin around paths

        Returns:
            SVG content as string
        """
        if not paths:
            return self._empty_svg(100, 100)

        # Calculate bounding box
        all_points = [p for path in paths for p in path.points]
        min_x = min(p[0] for p in all_points)
        min_y = min(p[1] for p in all_points)
        max_x = max(p[0] for p in all_points)
        max_y = max(p[1] for p in all_points)

        content_width = max_x - min_x
        content_height = max_y - min_y

        # SVG dimensions
        svg_width = width or (content_width + 2 * margin)
        svg_height = height or (content_height + 2 * margin)

        # Offset to center content
        offset_x = margin - min_x
        offset_y = margin - min_y

        # Get style
        svg_style = SVG_STYLES.get(style, SVG_STYLES['cut'])

        # Build SVG
        root = ET.Element('svg')
        root.set('xmlns', 'http://www.w3.org/2000/svg')
        root.set('width', f'{svg_width:.{self.precision}f}{self.unit}')
        root.set('height', f'{svg_height:.{self.precision}f}{self.unit}')
        root.set('viewBox', f'0 0 {svg_width:.{self.precision}f} {svg_height:.{self.precision}f}')

        # Add metadata
        metadata = ET.SubElement(root, 'metadata')
        metadata.text = f'Generated by Claude Fab Lab - {svg_style.operation} operation'

        # Add title
        title = ET.SubElement(root, 'title')
        title.text = f'Laser {svg_style.operation.title()} Path'

        # Create group for paths
        group = ET.SubElement(root, 'g')
        group.set('id', f'{style}_paths')
        group.set('stroke', svg_style.stroke_color)
        group.set('stroke-width', str(svg_style.stroke_width))
        group.set('fill', svg_style.fill)

        # Add paths
        for i, path in enumerate(paths):
            if len(path.points) < 2:
                continue

            # Build path data
            d = self._path_to_d(path, offset_x, offset_y)

            path_elem = ET.SubElement(group, 'path')
            path_elem.set('id', f'path_{i}')
            path_elem.set('d', d)

            if not path.is_outer:
                # Mark as hole with evenodd fill-rule
                path_elem.set('fill-rule', 'evenodd')

        return self._prettify(root)

    def export_result(self, result, style: str = 'cut', margin: float = 5.0) -> str:
        """
        Export CrossSectionResult or ProjectionResult to SVG.

        Args:
            result: CrossSectionResult or ProjectionResult
            style: SVG style name
            margin: Margin around content

        Returns:
            SVG content string
        """
        return self.paths_to_svg(result.paths, style=style, margin=margin)

    def save(self, paths: List[Path2D], filepath: str, style: str = 'cut', **kwargs):
        """
        Save paths to SVG file.

        Args:
            paths: List of Path2D objects
            filepath: Output file path
            style: SVG style name
            **kwargs: Additional arguments for paths_to_svg
        """
        svg_content = self.paths_to_svg(paths, style=style, **kwargs)

        filepath = Path(filepath)
        filepath.parent.mkdir(parents=True, exist_ok=True)

        with open(filepath, 'w') as f:
            f.write(svg_content)

    def save_result(self, result, filepath: str, style: str = 'cut', **kwargs):
        """Save result object to SVG file."""
        self.save(result.paths, filepath, style, **kwargs)

    def _path_to_d(self, path: Path2D, offset_x: float, offset_y: float) -> str:
        """Convert Path2D to SVG path data string."""
        if not path.points:
            return ""

        parts = []

        # Move to first point
        x, y = path.points[0]
        parts.append(f'M {x + offset_x:.{self.precision}f},{y + offset_y:.{self.precision}f}')

        # Line to remaining points
        for x, y in path.points[1:]:
            parts.append(f'L {x + offset_x:.{self.precision}f},{y + offset_y:.{self.precision}f}')

        # Close path if needed
        if path.is_closed:
            parts.append('Z')

        return ' '.join(parts)

    def _empty_svg(self, width: float, height: float) -> str:
        """Create empty SVG."""
        root = ET.Element('svg')
        root.set('xmlns', 'http://www.w3.org/2000/svg')
        root.set('width', f'{width}{self.unit}')
        root.set('height', f'{height}{self.unit}')
        root.set('viewBox', f'0 0 {width} {height}')
        return self._prettify(root)

    def _prettify(self, elem: ET.Element) -> str:
        """Return pretty-printed XML string."""
        rough_string = ET.tostring(elem, encoding='unicode')
        return minidom.parseString(rough_string).toprettyxml(indent='  ')


def export_to_svg(paths: List[Path2D], filepath: str, style: str = 'cut'):
    """
    Convenience function to export paths to SVG file.

    Args:
        paths: List of Path2D objects
        filepath: Output file path
        style: SVG style name
    """
    exporter = SVGExporter()
    exporter.save(paths, filepath, style)


def paths_to_svg(paths: List[Path2D], style: str = 'cut') -> str:
    """
    Convenience function to convert paths to SVG string.

    Args:
        paths: List of Path2D objects
        style: SVG style name

    Returns:
        SVG content string
    """
    exporter = SVGExporter()
    return exporter.paths_to_svg(paths, style)


# Test function
if __name__ == "__main__":
    # Create test paths
    test_paths = [
        Path2D(
            points=[(-25, -15), (25, -15), (25, 15), (-25, 15)],
            is_closed=True,
            is_outer=True
        ),
        Path2D(
            points=[(-10, -5), (10, -5), (10, 5), (-10, 5)],
            is_closed=True,
            is_outer=False  # This is a hole
        ),
    ]

    exporter = SVGExporter()
    svg_content = exporter.paths_to_svg(test_paths, style='cut')

    print("Generated SVG:")
    print(svg_content)

    # Save to file
    test_path = "/tmp/test_laser.svg"
    exporter.save(test_paths, test_path)
    print(f"\nSaved to: {test_path}")
